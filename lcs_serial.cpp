#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm>
#include "core/get_time.h"
#include "core/utils.h"

using namespace std;

#define DEFAULT_NUMBER_OF_THREADS "1"

// This function for reading the input from file that's generated by generator
vector<string> splitString(const string& str, char delimiter) {
    vector<string> tokens;
    stringstream ss(str);
    string token;
    while (getline(ss, token, delimiter)) {
        tokens.push_back(token);
    }
    return tokens;
}

pair<int, string> longestCommonSubsequence(const string& s1, const string& s2) {
    timer serial_time;
    int n = s1.size();
    int m = s2.size();

    vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

    // Simple background Idea base on the Bellman's Equation, 
    // That we provided in the report, please take a look
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            if (s1[i - 1] == s2[j - 1]) {
                dp[i][j] = dp[i - 1][j - 1] + 1; 
            } else {
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
            }
        }
    }

    string lcs = "";
    int i = n, j = m;
    while (i > 0 && j > 0) {
        if (s1[i - 1] == s2[j - 1]) {
            lcs += s1[i - 1]; 
            --i;
            --j;
        } else if (dp[i - 1][j] > dp[i][j - 1]) {
            --i;
        } else {
            --j;
        }
    }

    reverse(lcs.begin(), lcs.end());

    return {dp[n][m], lcs};
}

int main(int argc, char* argv[]) {
     cxxopts::Options options("Longest_common_subsequence",
                            "Calculate longest common subsequence using serial and parallel execution");
    options.add_options(
      "custom",
      {
          {"nThreads", "Number of threads",
           cxxopts::value<uint>()->default_value(DEFAULT_NUMBER_OF_THREADS)},
           {"inputFile", "Input file path for random numbers file", 
           cxxopts::value<std::string>()->default_value("inputs/rand_5000")},
      });
    auto cl_options = options.parse(argc, argv);
    int n_threads = cl_options["nThreads"].as<uint>();
    std::string input_file_path = cl_options["inputFile"].as<std::string>();

    ifstream inputFile(input_file_path);
    if (!inputFile) {
        cerr << "Error: Could not open file '" << input_file_path << "'." << endl;
        return 1;
    }

    if (n_threads != 1) {
        std::cout << "Serial version. Number of threads should be equal to 1. Terminating..." << std::endl;
        return 1;
    }

    string sequence1, sequence2;

    getline(inputFile, sequence1);
    getline(inputFile, sequence2);
    inputFile.close();

    vector<string> seq1Tokens = splitString(sequence1, ',');
    vector<string> seq2Tokens = splitString(sequence2, ',');

    string s1 = "";
    string s2 = "";
    for (const auto& ch : seq1Tokens) s1 += ch;
    for (const auto& ch : seq2Tokens) s2 += ch;

    timer serial_timer;

    serial_timer.start();
    pair<int, string> lcs = longestCommonSubsequence(s1, s2);
    double time_taken = serial_timer.stop();

    // Output the results
    std::cout << "Length of Longest Common Subsequence: " << lcs.first << std::endl;
    std::cout << "Longest Common Subsequence: " << lcs.second << std::endl;
    std::cout << "Time taken: " << time_taken << std::endl;

    return 0;
}
